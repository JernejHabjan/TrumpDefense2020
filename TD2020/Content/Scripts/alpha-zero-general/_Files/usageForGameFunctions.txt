GAME:
	getInitBoard:
		Arena
			board = getInitBoard()
			@@@@@self.display(board) - look for example for "def display(board) in OthelloGame
	
			
			self.game.getCannonicalForm(board)
			self.game.getNextState(board)
			self.game.getGameEnded(board
		Coach
			board = self.game.getInitBoard
			self.game.getCannonicalForm(board
			self.game.getNextState(board)
			self.game.getGameEnded(board)
	getBoardSize
		_mygame_NNet
			self.board_x, self.board_y = game.getBoardSize()
			x_image = Reshape((self.board_x, self.board_y, 1))(self.input_boards)  # batch_size  x board_x x board_y x 1
		NNet__in_my_game_NNet:
			self.board_x, self.board_y = game.getBoardSize() - actually not needed i think
	getActionSize
		MCTS
			counts = [self.Nsa[(s, a)] if (s, a) in self.Nsa else 0 for a in range(self.game.getActionSize())]
			
			# pick the action with the highest upper confidence bound
			for a in range(self.game.getActionSize()):
				# where valids -> valids = self.game.getValidMoves(canonical_board, 1)
				if valids[a]:
			
			
		NNet
			self.action_size = game.getActionSize() - probably not used
		_mygame_NNet
			used for layers
			self.fc3 = nn.Linear(512, self.action_size)
			pi = self.fc3(s)  # batch_size x action_size
			
		_mygame_Players
			random player:
				chooses random action that is valid
			greedy player:
				chooses the one with highest score
	
	getNextState
		
		Arena
			board, cur_player = self.game.getNextState(board, cur_player, action)
		Coach
			board, self.curPlayer = self.game.getNextState(board, self.curPlayer, action)
		MCTS
		    next_s, next_player = self.game.getNextState(canonical_board, 1, a)
			next_s = self.game.getCanonicalForm(next_s, next_player)

			v = self.search(next_s)
		_mygame_Players
			GreedyPlayeer
				next_board, _ = self.game.getNextState(board, 1, a)
				score = self.game.getScore(next_board, 1)
		
	getValidMoves:
		Arena
			valids = self.game.getValidMoves(self.game.getCanonicalForm(board, cur_player), 1)
		MCTS
			valids = self.game.getValidMoves(canonical_board, 1) ################### TLE JE PROBLEM------- ENKRAT MU DAM CANONICAL BOARD ENKRAT PA NAVADN BOARD
		_mygame_Players
			valids = self.game.getValidMoves(board, 1)
		
	getGameEnded
		Arena
		
		Coach
		MCTS
	
	getCannonicalForm
	
		Arena
			action = players[cur_player + 1](self.game.getCanonicalForm(board, cur_player))
				# executes function or method that player represents
				# human player -> <bound method HumanOthelloPlayer.play of <othello.OthelloPlayers.HumanOthelloPlayer object at ...>>
				# nnet player -> <function <lambda> at ....>
				
			valids = self.game.getValidMoves(self.game.getCanonicalForm(board, cur_player), 1)
			
			valids = self.game.getValidMoves(self.game.getCanonicalForm(board, cur_player), 1)

            if valids[action] == 0:
                print(action)

                assert valids[action] > 0
            board, cur_player = self.game.getNextState(board, cur_player, action)
			
		Coach
		
			canonical_board = self.game.getCanonicalForm(board, self.curPlayer)
            temp = int(episode_step < self.args.tempThreshold)

            pi = self.mcts.getActionProb(canonical_board, temp=temp)
            sym = self.game.getSymmetries(canonical_board, pi)
            for b, p in sym:
                train_examples.append([b, self.curPlayer, p, None])
		MCTS
			def search:
				next_s = self.game.getCanonicalForm(next_s, next_player)
				v = self.search(next_s) # recursively calls this function again
			
		
		
		
		
	getSymmetries:
		Coach:
			sym = self.game.getSymmetries(canonical_board, pi)
			for b, p in sym:
				train_examples.append([b, self.curPlayer, p, None])
				
				
				
	stringRepresentation:
		MCTS
			probability
				s = self.game.stringRepresentation(canonical_board)
				counts = [self.Nsa[(s, a)] if (s, a) in self.Nsa else 0 for a in range(self.game.getActionSize())]

				if temp == 0:
					best_a = np.argmax(counts)
					probs = [0] * len(counts)
					probs[best_a] = 1
					return probs

				counts = [x ** (1. / temp) for x in counts]
				probs = [x / float(sum(counts)) for x in counts]
				return probs

				
			search
				s = self.game.stringRepresentation(canonical_board)

				if s not in self.Es:
					self.Es[s] = self.game.getGameEnded(canonical_board, 1)